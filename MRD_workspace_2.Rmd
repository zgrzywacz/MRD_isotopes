---
title: "MRD_workspace_2"
author: "Zack Grzywacz"
date: "July 15, 2021"
output: html_document
---


```{r}
library(lubridate)
library(lattice)
library(rnaturalearth)
library(rnaturalearthdata)
library(rasterVis)
library(seas)
library(s2dverification)
library(reshape2)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(viridis)
library(ggExtra)
library(grid)
library(pheatmap)
library(treeclim)
library(raster)
library(dplR)
library(scPDSI)
```


```{r}
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}
```

```{r}
raw <- read.csv("raw_isotopes.csv") # Raw isotope data
raw$year <- substrRight(raw$sample_ID, 4)
raw$year <- strtoi(raw$year)

annual_summary <- raw %>% group_by(year) %>% summarise(mean = mean(o18corr, na.rm = TRUE)) # Combined Isotope data

tab <- read.csv("tabulated_18o.csv") # Oxygen data tabulated
rownames(tab) <- tab[,1]
tab[,1] <- NULL

tab2 <- read.csv("tabulated_13c.csv") # carbon data tabulated
rownames(tab2) <- tab2[,1]
tab2[,1] <- NULL

gnip <- read.csv("CG_GNIP.csv")
gnip$Date <- parse_date_time(gnip$Date, "mdy")
gnip$month <- month(gnip$Date)
gnip$year <- year(gnip$Date)
for (i in c(1:288)){
if (gnip$month[i] < 9){
  gnip$seas.year[i] = (gnip$year[i] - 1)
}
else{
  gnip$seas.year[i] = gnip$year[i]
}
}

gnip_outlier <- gnip
gnip_outlier$O18[gnip_outlier$O18 > 1] <- NA

vpd <- read.csv("vpd_monthly_1959_2019.csv")
vpd <- vpd[13:720,]

clim <- read.csv("silo_monthly_1959_2019.csv")
```

Standardize 18O series

```{r}
std_18o <- scale(tab)
```

Corr matrix

```{r}
cors_O18 <- cor(std_18o, use = "complete.obs")
```

Average interseries correlation:

```{r}
mean(cors_O18[cors_O18 != 1])
```

```{r}
std_13c <- scale(tab2)
cors_C13 <- cor(std_13c, use='complete.obs')
```

```{r}
mean(cors_C13[cors_C13 != 1])
```


The same - duh.

```{r}
std_summary <- rowMeans(std_18o, na.rm=TRUE)
```


Groupings

```{r}
downslope_sites <- subset(std_18o, select=c("X603","X605","X612","X619"))
upslope_sites <- subset(std_18o, select=c("X604","X607","X609","X611"))
cluster_group1 <- subset(std_18o, select=c("X603","X605","X609","X612","X619"))
cluster_group2 <- subset(std_18o, select=c("X604","X606","X607","X617"))
downslope_summary <- data.frame(rowMeans(downslope_sites, na.rm=TRUE))
colnames(downslope_summary) <- "mean"
upslope_summary <- data.frame(rowMeans(upslope_sites, na.rm=TRUE))
colnames(upslope_summary) <- "mean"
group1_summary <- data.frame(rowMeans(cluster_group1, na.rm=TRUE))
colnames(group1_summary) <- "mean"
group2_summary <- data.frame(rowMeans(cluster_group2, na.rm=TRUE))
colnames(group2_summary) <- "mean"
```



Make correlation function that corrs parameter plus lag
Take all factors -> output plot/table


Change this slightly to allow for nextyr corrs as well
```{r}
o18_corrs <- function(df, trees){
  prevclim <- df[1:708,]
  newclim <- df[13:720,]
  nextclim <- df[25:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
  output <- rbind(output, tempdf0, tempdf, tempdf2)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May")
  return(output)
}
```


```{r}
o18_corrs(clim, annual_summary$mean)
```



Figure out scPDSI

Take this output and add it to clim data frame

```{r}
pdsi_output <- pdsi(clim$precip, clim$pet, start=1959, sc=TRUE)
```

```{r}
clim$pdsi <- pdsi_output$X
clim = subset(clim, select = -c(pet) )
```

```{r}
o18_corrs(clim, annual_summary$mean)
```


```{r}
newdf <- o18_corrs(clim, std_summary)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```


Groupings:

```{r}
newdf <- o18_corrs(clim, downslope_summary$mean)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Downslope Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```


```{r}
newdf <- o18_corrs(clim, upslope_summary$mean)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Upslope Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```

```{r}
plot(clim$pdsi)
```

```{r}
mon_test <- subset(clim, month==12)
plot(mon_test[2:60,]$pdsi, std_summary)
```


Individual Trees:

```{r}
newdf <- o18_corrs(clim, std_18o[,10])
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="619")+geom_point(data=newdf[newdf$p<0.05,])
gg
```

```{r}
std_18o
```


C Seuss correction
Ask Amy - seems complicated

Corrected 13C = (tree ring 13C) - (atmosphere d13CO2 + pre-industrial d13CO2)
Pre-industrial is ~ -6.4 (I think)

Load in atmosphere data -> add pre-industrial -> subtract from tree ring 

```{r}
testdf<- read.csv("monthly_flask_c13_mlo.csv")
testdf <- testdf[c(1:2,9)]
c13_atm <- testdf[9:512,]
colnames(c13_atm) <- c("Yr","Mn","C13")
c13_atm$C13 <- as.numeric(c13_atm$C13)
c13_atm[1,3] <- NA
```

```{r}
annual_c13_atm <- c13_atm %>% group_by(Yr) %>% summarise(c13 = mean(C13, na.rm=TRUE))
annual_c13_atm$corrected <- (annual_c13_atm$c13 - 6.4)
carbon_correction <- tab2[21:59,]
split_annual_c13 <- annual_c13_atm[1:39,]
new_c13 <- carbon_correction - split_annual_c13$corrected
new_c13
```

```{r}
std_13c <- data.frame(scale(new_c13))
std_13c <- std_13c[,-4]
c13_summary <- rowMeans(std_13c, na.rm=TRUE)
c13_summary
```

```{r}
plot(names(c13_summary), c13_summary)
```



```{r}
cor(new_c13, use="complete.obs")
```


```{r}
cor.test(c13_summary, std_summary[21:59])
```

```{r}
c13_corrs <- function(df, trees){
  prevclim <- df[241:708,]
  newclim <- df[253:720,]
  nextclim <- df[265:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
  output <- rbind(output, tempdf0, tempdf, tempdf2)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May")
  return(output)
}
```



```{r}
clim_for_carbon <- clim[,-3]
```


```{r}
c13_df <- c13_corrs(clim_for_carbon, c13_summary)
c13_df$Month <- factor(c13_df$Month, levels=unique(c13_df$Month))
gg <- ggplot(c13_df, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Carbon Monthly Correlations")+geom_point(data=c13_df[c13_df$p<0.05,])
gg
```

Relationship with VPD makes perfect sense
High VPD = closed stomata = "internal concentration of CO2 will drop and there will be less carboxylation discrimination against 13C, leading to higher d13C values"
I wonder why there is not a positive relationship with pdsi - drought should mean closed stomata
"d13C is only an indicator of drought stress in seasonally dry climates, and that variation in irradiance and N concentration can have as large an affect on discrimination as water availability"
Irradiance and temperature may be dominant in this environment, where moisture stress is not an issue
A negative relationship with solar radiation doesn't make sense at first - should lead to higher photosynthesis and thus higher 13C values
However, it isn't necessarily a negative relationship during the growing season - it's during the spring and fall
One possibility - higher irradiance in the spring and fall = sunny, but cold. Shouldn't be much photosynthesis happening (?)
It's also strange that temp and rad have near opposite relationships with carbon despite being positively related to each other

```{r}
monthtest <- subset(clim, month ==1)
plot(tab$X612, monthtest[3:61,]$gnip)
```


There is the possibility that this is not a very stressed area and the 13C signal will be difficult to interpret

No need to mess too much with the Suess stuff - Using the exact method described in McCarroll and Loader will result in the same relationships, just different numbered values. POSSIBLY find a different dataset that extends all the way to 1960 so that the whole dataset can be used.





Create yearly averages

Combine all of the ERA data together into a single stack (AND CROP TO 1958 - 2013! Change this if needed)



New function
subset raster brick to years (60-18, then 61-19)
Extract All raster layers for a particular month (Jan 1960, 61, etc)
Turn into array
Correlate as if it's a time series with the o18 (see below?)

Alternatively, extract just a growing season then correlate by year (using calc which doesn't seem to be working)

```{r}
datC <- brick("rasters/ERA5_t2m.gri")
datC_curr <- subset(datC, 121:828)
datC_next <- subset(datC, 133:840)

month <- "03" # Year you want to subset

sel_y <- names(datC_next)[substr(names(datC_next), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_next, sel_y, value=T) #subsets the dataset of only those that are true
tail(names(datY), 30)
ar.datY <- as.array(datY)
```

This works as is. Just change the parameter being used

```{r}
datC <- brick("rasters/ERA5_precip.gri")
  datC_curr <- subset(datC, 121:828)
  datC_next <- subset(datC, 133:840)
  
# Curr yr
  
for (month in c("06","07","08","09","10","11","12")){
sel_y <- names(datC_curr)[substr(names(datC_curr), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_curr, sel_y, value=T) #subsets the dataset of only those that are true
ar.datY <- as.array(datY)

z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
for (x in 1:259200)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}

l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)

r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
writeRaster(r, paste0("precip_corr_test_curr_", month))

}
  
# Next yr  
  
for (month in c("01","02","03","04","05")){
sel_y <- names(datC_next)[substr(names(datC_next), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_next, sel_y, value=T) #subsets the dataset of only those that are true
ar.datY <- as.array(datY)

z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
for (x in 1:259200)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}

l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)

r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
writeRaster(r, paste0("precip_corr_test_next_", month))

}
```





```{r}
apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
```

This is in list form basically. The cells go like this

1   5   9   13  17
2   6   10  14  18
3   7   11  15  19
4   8   12  16  20

```{r}
z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
```

correlation = z[[x]][[1]][2]
significance = z[[x]][[3]][2]

Up next: create corr and sig arrays

Change (67,89) to new extent:

corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
```{r}
corr = array(0, dim=c(18,20) )
sig = array(0, dim=c(18,20) )
```

Change 5963 to number of cells in new extent (ensure routing is correct):
for (x in 1:259200)
Must transpose corr and sig to get right dimensions
```{r}
for (x in 1:360)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}
```




Make it the right structure(?)

```{r}
l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)
a
```

Change this brick call to get correct resolution, extent, etc
```{r}
r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
r
```
0.125, 180.125, -89.875, 0.125  (xmin, xmax, ymin, ymax)
```{r}
plot(r)
```

Create raster of corrs:

```{r}
writeRaster(r, "o18_prcp_corr")
```












