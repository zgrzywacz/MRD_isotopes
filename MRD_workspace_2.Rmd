---
title: "MRD_workspace_2"
author: "Zack Grzywacz"
date: "July 15, 2021"
output: html_document
---


```{r}
library(lubridate)
library(lattice)
library(rnaturalearth)
library(rnaturalearthdata)
library(rasterVis)
library(seas)
library(s2dverification)
library(reshape2)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(viridis)
library(ggExtra)
library(grid)
library(pheatmap)
library(treeclim)
library(raster)
library(dplR)
library(scPDSI)
library(tidyr)
```


```{r}
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}
```

```{r}
raw <- read.csv("raw_isotopes.csv") # Raw isotope data
raw$year <- substrRight(raw$sample_ID, 4)
raw$year <- strtoi(raw$year)

annual_summary <- raw %>% group_by(year) %>% summarise(mean = mean(o18corr, na.rm = TRUE)) # Combined Isotope data

tab <- read.csv("tabulated_18o.csv") # Oxygen data tabulated
rownames(tab) <- tab[,1]
tab[,1] <- NULL

tab2 <- read.csv("tabulated_13c.csv") # carbon data tabulated
rownames(tab2) <- tab2[,1]
tab2[,1] <- NULL

gnip <- read.csv("CG_GNIP.csv")
gnip$Date <- parse_date_time(gnip$Date, "mdy")
gnip$month <- month(gnip$Date)
gnip$year <- year(gnip$Date)
for (i in c(1:288)){
if (gnip$month[i] < 9){
  gnip$seas.year[i] = (gnip$year[i] - 1)
}
else{
  gnip$seas.year[i] = gnip$year[i]
}
}

gnip_outlier <- gnip
gnip_outlier$O18[gnip_outlier$O18 > 1] <- NA

vpd <- read.csv("vpd_monthly_1959_2019.csv")
vpd <- vpd[13:720,]

clim <- read.csv("silo_monthly_1959_2019.csv")

prysm <- read.csv("prysm_full.csv")

echam5 <- read.csv("echam5wiso_MRD.csv")
```


```{r}
clim$prysm <- as.numeric(NA)
clim[1:660,]$prysm <- prysm[13:672,]$d18o
clim$echam5 <- as.numeric(NA)
clim[1:660,]$echam5 <- echam5[13:672,]$d18oP
```

Visualize 18O series

```{r}
raw$year <- as.factor(raw$year)
ggplot(raw, aes(x=year, y=o18corr)) + 
  geom_boxplot(fill='#E69F00', color='black')
```



Standardize 18O series

```{r}
std_18o <- scale(tab)
```

Corr matrix

```{r}
cors_O18 <- cor(std_18o, use = "complete.obs")
```

Average interseries correlation:

```{r}
mean(cors_O18[cors_O18 != 1])
```

```{r}
std_13c <- scale(tab2)
cors_C13 <- cor(std_13c, use='complete.obs')
```

```{r}
mean(cors_C13[cors_C13 != 1])
```


The same - duh.

```{r}
std_summary <- rowMeans(std_18o, na.rm=TRUE)
```

Compare MRD station to SILO

```{r}
MRDprecip <- read.csv("MRD_station_precip.csv")
MRDprecip <- MRDprecip[,3:5]
colnames(MRDprecip)[3] <- "Precip"
MRDtemp <- read.csv("MRD_station_temp.csv")
MRDtemp <- MRDtemp[,3:5]
colnames(MRDtemp)[3] <- "Temp"
MRDrad <- read.csv("MRD_station_rad.csv")
MRDrad <- MRDrad[,3:5]
colnames(MRDrad)[3] <- "Rad"
MRDprecip <- complete(MRDprecip, expand(MRDprecip, Year, Month))
MRDtemp <- complete(MRDtemp, expand(MRDtemp, Year, Month))
MRDrad <- complete(MRDrad, expand(MRDrad, Year, Month))
```

```{r}
plot(MRDprecip[1:276,]$Precip, clim[457:732,]$precip)
plot(MRDtemp[1:288,]$Temp, clim[445:732,]$temp)
plot(MRDrad[1:360,]$Rad, clim[373:732,]$rad)
```

```{r}
Precip_compare <- data.frame(year=clim[457:732,]$year, month=clim[457:732,]$month, station = MRDprecip[1:276,]$Precip, silo = clim[457:732,]$precip)
Precip_compare$monthSilo <- as.numeric(NA)
for (i in 1:276){
  if (Precip_compare[i,2]%in% c(1,3,5,7,8,10,12) == TRUE ){
    Precip_compare[i,5] <- Precip_compare[i,4]*31
  }
  else if (Precip_compare[i,2]%in% c(4,6,9,11) == TRUE ){
    Precip_compare[i,5] <- Precip_compare[i,4]*30
  }
  else{
    Precip_compare[i,5] <- Precip_compare[i,4]*28
  }
}
```




```{r}
Temp_compare <- data.frame(station = MRDtemp[1:288,]$Temp, silo = clim[445:732,]$temp)
Rad_compare <- data.frame(station = MRDrad[1:360,]$Rad, silo = clim[373:732,]$rad)
```

CHANGE PRECIP to mm total or mm/day (figure hour how I did mm/day the first time)
Repeat this plot for temp and rad

```{r}
ggplot(Precip_compare, aes(station, monthSilo))+
  geom_point(shape=23, color="blue")+
  xlab("MRD Station Precipitation")+
  ylab("SILO Precipitation")
```


Station data follows closely. BUT is there a significant change pre-199x (whenever station comes in)

rad - 1990
temp - 1996
precip - 1997

```{r}
plot(clim$precip, type="l")
```
 
```{r}
plot(MRDprecip$Precip, type="l")
```
 
 
 Seasonal spread appears to be slighlty higher post-1997. Investigate further:
 
```{r}
plot(subset(clim, month == 2)$year, subset(clim, month == 12)$precip)
```

Some months do appear to have increased spread after 1997. As in, year-to-year changes have more variability, and as a result there also appears to be more intra-year spread when all points are plotted. However, this could also be the result of a slight positive trend, which may or may not have been captured by the pre-1997 version of the model
 
 
```{r}
plot(MRDtemp$Temp, type="l")
```
 Seems fine to me
 
 
```{r}
plot(clim$year, clim$rad)
```
 Looks fine to me.


Climograph from MRD station data:

```{r}
ggdf <- data.frame(Month = MRDtemp$Month )
ggdf$Month <- month.abb
ggdf$Month <- factor(ggdf$Month, levels = month.abb)
ggdf$meanT <- as.numeric(MRDtemp$Temp)
ggdf$prec_mm <- as.numeric(NA)
ggdf[13:312,]$prec_mm <- MRDprecip$Precip

ggdf <- ggdf %>% group_by(Month) %>% summarise(meanT = mean(meanT, na.rm=TRUE), prec_mm = mean(prec_mm, na.rm=TRUE))
```





```{r}
climograph <- ggplot(data = ggdf, mapping = aes(x = Month, y = prec_mm, group = 1)) + 
  geom_bar(stat = "identity", color="#404788FF", fill="#404788FF", width = 0.5) + 
  geom_line(aes(y = meanT*30, group=1), color="#3CBB75FF", size=1.5) + # Scale data to match desired scale
  scale_y_continuous("Precipitation [mm]", 
                     sec.axis = sec_axis(~ . /30, name = "Temperature [Â°C]") # Reverse transformation to match data
  ) +
   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))
```


```{r}
climograph
```


Groupings

```{r}
downslope_sites <- subset(std_18o, select=c("X603","X605","X612","X619"))
upslope_sites <- subset(std_18o, select=c("X604","X607","X609","X611"))
cluster_group1 <- subset(std_18o, select=c("X603","X605","X609","X612","X619"))
cluster_group2 <- subset(std_18o, select=c("X604","X606","X607","X617"))
downslope_summary <- data.frame(rowMeans(downslope_sites, na.rm=TRUE))
colnames(downslope_summary) <- "mean"
upslope_summary <- data.frame(rowMeans(upslope_sites, na.rm=TRUE))
colnames(upslope_summary) <- "mean"
group1_summary <- data.frame(rowMeans(cluster_group1, na.rm=TRUE))
colnames(group1_summary) <- "mean"
group2_summary <- data.frame(rowMeans(cluster_group2, na.rm=TRUE))
colnames(group2_summary) <- "mean"
```



Make correlation function that corrs parameter plus lag
Take all factors -> output plot/table


Change this slightly to allow for nextyr corrs as well
```{r}
o18_corrs <- function(df, trees){
  prevclim <- df[1:708,]
  newclim <- df[13:720,]
  nextclim <- df[25:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
  output <- rbind(output, tempdf0, tempdf, tempdf2)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May")
  return(output)
}
```

```{r}
subset(clim, month == 1)
```

```{r}
o18_corrs(clim, annual_summary$mean)
```



Figure out scPDSI

Take this output and add it to clim data frame

```{r}
pdsi_output <- pdsi(clim$precip, clim$pet, start=1959, sc=TRUE)
```

```{r}
pdsi_output
```


```{r}
clim$pdsi <- pdsi_output$X
```

```{r}
o18_corrs(clim, annual_summary$mean)
```

```{r}
clim <- clim[,c(-10)]
```


```{r}
newdf <- o18_corrs(clim, std_summary)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```


Groupings:

```{r}
newdf <- o18_corrs(clim, downslope_summary$mean)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Downslope Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```


```{r}
newdf <- o18_corrs(clim, upslope_summary$mean)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Upslope Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```

```{r}
plot(clim$pdsi)
```


```{r}
mon_test <- subset(clim, month==12)
plot(mon_test[2:60,]$pdsi, std_summary)
```


Individual Trees:

```{r}
newdf <- o18_corrs(clim, std_18o[,10])
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="619")+geom_point(data=newdf[newdf$p<0.05,])
gg
```

```{r}
std_18o
```

```{r}
DJF <- subset(clim, month == 12 | month == 1 | month == 2)
DJF$seasyear <- ifelse(DJF$month>=12, DJF$year, (DJF$year-1))
DJF_gnip <- group_by(DJF, seasyear) %>% summarise(mean=mean(gnip, na.rm=TRUE))
```

```{r}
DJF_gnip_trim <- DJF_gnip[3:61,]
cor.test(DJF_gnip_trim$mean, group2_summary$mean)
```


C Seuss correction
Ask Amy - seems complicated

Corrected 13C = (tree ring 13C) - (atmosphere d13CO2 + pre-industrial d13CO2)
Pre-industrial is ~ -6.4 (I think)

Load in atmosphere data -> add pre-industrial -> subtract from tree ring 


```{r}
testdf<- read.csv("monthly_dc13_atm.csv")
testdf <- testdf[c(1,5)]
c13_atm <- testdf[5:170,]
colnames(c13_atm) <- c("Yr","C13")
c13_atm$C13 <- as.numeric(c13_atm$C13)
c13_atm$Yr <- c(1850:2015)
```

```{r}
plot(c13_atm[110:166,]$Yr, c13_atm[110:166,]$C13)
```

```{r}
baringhead <- read.csv("monthly_flask_c13_nzd.csv")
baringhead <- baringhead[5:432,c(1,8)]
BH_record <- baringhead %>% group_by(Yr) %>% summarise(mean = mean(C13..filled))
BH_correction <- mean(c13_atm[136:166,]$C13 - BH_record[1:31,]$mean)
c13_atm$BH_shift <- c13_atm$C13 - BH_correction
c13_atm[136:170,]$BH_shift <- BH_record[1:35,]$mean
```



```{r}
c13_atm$corrected <- (c13_atm$BH_shift + 6.51)
split_annual_c13 <- c13_atm[111:170,]
new_c13 <- tab2 - split_annual_c13$corrected
new_c13
```

```{r}
std_13c <- data.frame(scale(new_c13))
std_13c <- std_13c[,-4]
c13_summary <- rowMeans(std_13c, na.rm=TRUE)
c13_summary
```

```{r}
plot(names(c13_summary), c13_summary)
```
Compare to uncorrected: 

```{r}
plot(names(rowMeans(tab2)), rowMeans(tab2[,-4], na.rm=TRUE))
```

While 1980ish is the period where a lot of different measurements come on, it appears that the jump is introduced by the tree rings, not the suess correction


Plotting Graven vs. Uncorrected Raw vs. Suess Corrected

```{r}
plot(c(1960:2018), rowMeans(scale(tab2[-4]), na.rm=TRUE), type="l",col="red")
lines(c(1960:2018), c13_summary, col="blue")
lines(c(1960:2018), scale(split_annual_c13[1:59,]$BH_shift), col="green")
```

Red = RAW uncorrected (except 606)
Blue = Suess-corrected
Green = Graven/BH record

Clearly the weird jump is introduced by the trees, not the atmospheric record







```{r}
cor(new_c13, use="complete.obs")
```


```{r}
cor.test(c13_summary, std_summary[1:59])
```

```{r}
c13_corrs <- function(df, trees){
  prevclim <- df[1:708,]
  newclim <- df[13:720,]
  nextclim <- df[25:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
  output <- rbind(output, tempdf0, tempdf, tempdf2)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May")
  return(output)
}
```

```{r}
plot(clim$temp, type="l")
```


```{r}
clim_for_carbon <- clim[,c(-3,-10,-11)]
```


```{r}
c13_df <- c13_corrs(clim_for_carbon, c13_summary)
c13_df$Month <- factor(c13_df$Month, levels=unique(c13_df$Month))
gg <- ggplot(c13_df, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Carbon Monthly Correlations")+geom_point(data=c13_df[c13_df$p<0.05,])
gg
```
Update after using BH: Not much left for relationships....


Relationship with VPD makes perfect sense
High VPD = closed stomata = "internal concentration of CO2 will drop and there will be less carboxylation discrimination against 13C, leading to higher d13C values"
I wonder why there is not a positive relationship with pdsi - drought should mean closed stomata
"d13C is only an indicator of drought stress in seasonally dry climates, and that variation in irradiance and N concentration can have as large an affect on discrimination as water availability"
Irradiance and temperature may be dominant in this environment, where moisture stress is not an issue
A negative relationship with solar radiation doesn't make sense at first - should lead to higher photosynthesis and thus higher 13C values
However, it isn't necessarily a negative relationship during the growing season - it's during the spring and fall
One possibility - higher irradiance in the spring and fall = sunny, but cold. Shouldn't be much photosynthesis happening (?)
It's also strange that temp and rad have near opposite relationships with carbon despite being positively related to each other

```{r}
monthtest <- subset(clim, month ==1)
plot(tab$X612, monthtest[3:61,]$gnip)
```


There is the possibility that this is not a very stressed area and the 13C signal will be difficult to interpret

No need to mess too much with the Suess stuff - Using the exact method described in McCarroll and Loader will result in the same relationships, just different numbered values. POSSIBLY find a different dataset that extends all the way to 1960 so that the whole dataset can be used.

Treeclim testing

```{r}
clim_for_treeclim <- clim[,c(1,2,4,5)]
```

```{r}
annual_summary <- as.data.frame(annual_summary)
rownames(annual_summary) <- (annual_summary$year + 1)
annual_summary[,1] <- NULL
annual_summary$samp.depth <- c(8,8,8,6,8,7,8,7,9,9,9,9,9,6,7,7,7,7,7,8,9,9,8,8,9,9,9,7,9,9,9,8,9,8,9,9,9,8,9,8,9,9,10,10,10,10,10,9,9,9,10,9,10,10,10,10,10,9,9)
```

```{r}
annual_summary$mean <- std_summary
```


```{r}
dcc(annual_summary, clim_for_treeclim, .range(-1:12))
```

Rad shows decent relationships in prev aug, prev dec, curr jun.


```{r}
sc1 <- seascorr(annual_summary, clim_for_treeclim, primary = "precip", secondary = "temp")
sc2 <- seascorr(annual_summary, clim_for_treeclim, primary = "temp", secondary = "precip")
plot(sc1)
plot(sc2)
```
Growing season/late growing season precip appears significant - but in the wrong direction

Previous year temp appears significant as well?

Explanation:
Positive relationship with prev spring temp could mean early summers - which means an early growing season - leading trees to take in more growing season 18O which is more enriched. Negative relationship in fall - neglgible but could still be season extension snafu? If it's warmer and trees are still recording O, but the signal is depleted somehow? This could mean that being warmer at the site doesn't necessarily mean it's warmer at the source.

Positive with late summer/fall precip. Definitely odd. But precip at the site may not be very influential anyway (except as a weak proxy for RH). More fall precip could mean winter came early, thus the trees stopped recording earlier. 

Both of these explanations mean that trees take signal from local climate as to when to start recording/stop recording 18O. This is predicated upon the assumption that 18O is only recorded during the growing season. A SOURCE WATER change could also be very influential here.

Questions: Why do relationships get so much stronger for partial corrs than they are for dcc? 
Is there a source region seasonal pattern that could cause this relationship when the season is extended in either direction? (As far as SAM goes, there does not appear to be a consistent seasonal trend)
DO these trees record just growing season? I think so - because if not, why is January the significant GNIP month?

Try with VPD (RH) and PET just to try it

```{r}
clim_for_treeclim2 <- clim[,c(1,2,5,6)]
clim_for_treeclim3 <- clim[,c(1,2,5,7)]
plot(seascorr(annual_summary, clim_for_treeclim2, primary = "vpd", secondary = "temp"))
plot(seascorr(annual_summary, clim_for_treeclim2, primary = "temp", secondary = "vpd"))
plot(seascorr(annual_summary, clim_for_treeclim3, primary = "pet", secondary = "temp"))
plot(seascorr(annual_summary, clim_for_treeclim3, primary = "temp", secondary = "pet"))
```

VPD and PET follow very similar patterns - strong positive correlations in Spring/early Summer
Would line up with temp trends in precip/temp partial corrs, but temp looks weaker here. Could this be due to the same seasonal extension I predicted before?
Although it appears I still need more info on how these partial corrs work. I'm unsure what the primary/secondary designation means exactly

TRIM SILO TO 90ish

MRD series:

```{r}
MRD <- read.csv("mrd.txt", sep=" ")
```

```{r}
rwd_corrs <- function(df, trees){
  prevclim <- df[1:708,]
  newclim <- df[13:720,]
  nextclim <- df[25:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
  output <- rbind(output, tempdf0, tempdf, tempdf2)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May")
  return(output)
}
```

```{r}
trimMRD <- MRD[2400:2458,]
```

```{r}
rwd_corrs(clim, trimMRD$mrdstd)
```

```{r}
mrd_df <- rwd_corrs(clim, trimMRD$mrdstd)
mrd_df$Month <- factor(mrd_df$Month, levels=unique(mrd_df$Month))
gg <- ggplot(mrd_df, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="MRD Ring Width Monthly Correlations")+geom_point(data=mrd_df[mrd_df$p<0.05,])
gg
```

```{r}
dccMRD <- trimMRD
rownames(dccMRD) <- (as.numeric(rownames(trimMRD))+1)
dcc(dccMRD, clim_for_treeclim, .range(-1:12))
```

```{r}
sc1 <- seascorr(dccMRD, clim_for_treeclim, primary = "precip", secondary = "temp")
sc2 <- seascorr(dccMRD, clim_for_treeclim, primary = "temp", secondary = "precip")
plot(sc1)
plot(sc2)
```


Fine-tuning: Does GNIP CG reflect nearby GNIP stations?


```{r}
gnip_sites <- read.csv("other_gnip_sites.csv")
```

```{r}
plot(clim[217:600,]$gnip, gnip_sites$nz)
plot(clim[217:600,]$gnip, gnip_sites$margate)
cor.test(clim[217:600,]$gnip, gnip_sites$nz)
```

There is a bit of variability, but decent correlation with Invercargill site. Margate is too few data points to make anything of. Values are different, but there are different moisture sources, which makes that make sense.


Trying with MEDIAN:

```{r}
med_summary = apply(tab, 1, median, na.rm=T)
med_c_summary = apply(new_c13[,-4], 1, median, na.rm=T)
```

```{r}
newdf <- o18_corrs(clim, med_summary)
newdf$Month <- factor(newdf$Month, levels=unique(newdf$Month))
gg <- ggplot(newdf, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Monthly Correlations")+geom_point(data=newdf[newdf$p<0.05,])
gg
```

```{r}
c13_df <- c13_corrs(clim_for_carbon, med_c_summary)
c13_df$Month <- factor(c13_df$Month, levels=unique(c13_df$Month))
gg <- ggplot(c13_df, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="Carbon Monthly Correlations")+geom_point(data=c13_df[c13_df$p<0.05,])
gg
```

```{r}
annual_summary$mean <- med_summary
```


```{r}
dcc(annual_summary, clim_for_treeclim, .range(-1:12))
```

```{r}
sc1 <- seascorr(annual_summary, clim_for_treeclim, primary = "precip", secondary = "temp")
sc2 <- seascorr(annual_summary, clim_for_treeclim, primary = "temp", secondary = "precip")
plot(sc1)
plot(sc2)
```


Creating DJF Corrs (change season as needed)


This doesn't work, we can make it work?
```{r}
gs_corrs <- function(df, trees){
  prevclim <- df[1:708,]
  newclim <- df[13:720,]
  nextclim <- df[25:732,]
  output <- data.frame(Clim="", Month="", Corr="", p="")
  for (param in c(3:ncol(df))){
    tempdf0 <- data.frame(Clim=colnames(df[param]), Month=c(11:12), Corr="", p="")
    tempdf <- data.frame(Clim=colnames(df[param]), Month=c(1:12), Corr="", p="")
    tempdf2 <- data.frame(Clim=colnames(df[param]), Month=c(1:5), Corr="", p="")
    tempdf3 <- data.frame(Clim=colnames(df[param]), Month=c(13), Corr="", p="")
    for (m in 11:12){
      n = (m-10)
      mon_sub <- subset(prevclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf0$Corr[n] <- test$estimate
      tempdf0$p[n] <- test$p.value
    }
    for (m in 1:12){
      mon_sub <- subset(newclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf$Corr[m] <- test$estimate
      tempdf$p[m] <- test$p.value
    }
    for (m in 1:5){
      mon_sub <- subset(nextclim, month == m)
      test <- cor.test(mon_sub[[param]], trees)
      tempdf2$Corr[m] <- test$estimate
      tempdf2$p[m] <- test$p.value
    }
    dec_sub <- subset(newclim, month == 12)
    dec_sub$year <- (dec_sub$year + 1)
    djf_sub <- rbind(dec_sub, subset(nextclim, month == c(1,2)))
    djf_mean <- djf_sub %>% group_by(year)
    djf_sum <- summarise(djf_mean, mean = mean(as.formula(colnames(df[param])), na.rm=TRUE))
    djf_test <- cor.test(djf_sum$mean, trees)
    tempdf3[1]$Corr <- djf_test$estimate
    tempdf3[1]$p <- djf_test$p.value
  output <- rbind(output, tempdf0, tempdf, tempdf2, tempdf3)
  }
  output <- output[-1,]
  output$Corr <- as.numeric(output$Corr)
  output$p <- as.numeric(output$p)
  output$Month <- c("P.Nov","P.Dec","P.Jan","P.Feb","P.Mar","P.Apr","P.May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","Jan","Feb","Mar","Apr","May","DJF")
  return(output)
}
```


THIS WORKS:
```{r}
dec_sub <- subset(clim[25:722,], month == c(1,2))
dec_sub$year <- (dec_sub$year - 1)
djf_sub <- rbind(dec_sub, subset(clim[13:722,], month == 12))
djf_mean <- djf_sub %>% group_by(year) %>% summarise(gnip = mean(gnip, na.rm=TRUE), precip = mean(precip, na.rm=TRUE), temp = mean(temp, na.rm=TRUE), vpd = mean(vpd, na.rm=TRUE), vpd = mean(vpd, na.rm=TRUE), rh = mean(rh, na.rm=TRUE))
djf_corrs <- data.frame(Clim=colnames(djf_mean[,-1]), Month=c("DJF"), Corr="", p="")
for (param in c(2:ncol(djf_mean))){
    m = param-1
    test <- cor.test(djf_mean[[param]], std_summary)
    djf_corrs[m,3] <- test$estimate
    djf_corrs[m,4] <- test$p.value
}
```

Plot doesn't work
```{r}
gg <- ggplot(djf_corrs, aes(x=Month, y=Clim, fill=Corr)) + geom_tile(color="white", size=0.1) + scale_fill_viridis(name="# Events") + coord_equal() + labs(x=NULL, y=NULL, title="DJF")+geom_point(data=mrd_df[mrd_df$p<0.05,])
gg
```










Create yearly averages

Combine all of the ERA data together into a single stack (AND CROP TO 1958 - 2013! Change this if needed)



New function
subset raster brick to years (60-18, then 61-19)
Extract All raster layers for a particular month (Jan 1960, 61, etc)
Turn into array
Correlate as if it's a time series with the o18 (see below?)

Alternatively, extract just a growing season then correlate by year (using calc which doesn't seem to be working)

```{r}
datC <- brick("rasters/ERA5_t2m.gri")
datC_curr <- subset(datC, 121:828)
datC_next <- subset(datC, 133:840)

month <- "03" # Year you want to subset

sel_y <- names(datC_next)[substr(names(datC_next), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_next, sel_y, value=T) #subsets the dataset of only those that are true
tail(names(datY), 30)
ar.datY <- as.array(datY)
```

This works as is. Just change the parameter being used

```{r}
datC <- brick("rasters/ERA5_RH.gri")
  datC_curr <- subset(datC, 121:828)
  datC_next <- subset(datC, 133:840)
  
# Curr yr
  
for (month in c("06","07","08","09","10","11","12")){
sel_y <- names(datC_curr)[substr(names(datC_curr), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_curr, sel_y, value=T) #subsets the dataset of only those that are true
ar.datY <- as.array(datY)

z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
for (x in 1:259200)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}

l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)

r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
writeRaster(r, paste0("RH_corr_test_curr_", month))

}
  
# Next yr  
  
for (month in c("01","02","03","04","05")){
sel_y <- names(datC_next)[substr(names(datC_next), 7, 8) %in% month] #Creates true/false field of rasters for that yr
#use that index to subset the raster brick
datY <- subset(datC_next, sel_y, value=T) #subsets the dataset of only those that are true
ar.datY <- as.array(datY)

z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
for (x in 1:259200)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}

l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)

r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
writeRaster(r, paste0("RH_corr_test_next_", month))

}
```


```{r}
plot(raster("rasters/results/evap/evap_corr_test_next_01.gri"))
```



```{r}
apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
```

This is in list form basically. The cells go like this

1   5   9   13  17
2   6   10  14  18
3   7   11  15  19
4   8   12  16  20

```{r}
z <- apply(ar.datY, 1:2, rcorr, std_summary, type="pearson")
```

correlation = z[[x]][[1]][2]
significance = z[[x]][[3]][2]

Up next: create corr and sig arrays

Change (67,89) to new extent:

corr = array(0, dim=c(360,720) )
sig = array(0, dim=c(360,720) )
```{r}
corr = array(0, dim=c(18,20) )
sig = array(0, dim=c(18,20) )
```

Change 5963 to number of cells in new extent (ensure routing is correct):
for (x in 1:259200)
Must transpose corr and sig to get right dimensions
```{r}
for (x in 1:360)
{
corr[x] <- z[[x]][[1]][2]
sig[x] <- z[[x]][[3]][2]
}
```




Make it the right structure(?)

```{r}
l <- list(corr, sig)
a <- do.call(rbind, l)
library(abind)
a <- abind(l, along=3)
a
```

Change this brick call to get correct resolution, extent, etc
```{r}
r <- brick(a, xmn=0.125, xmx=180.125, ymn=-89.875, ymx=0.125, crs=CRS("+proj=longlat +datum=WGS84"))
r
```
0.125, 180.125, -89.875, 0.125  (xmin, xmax, ymin, ymax)
```{r}
plot(r)
```

Create raster of corrs:

```{r}
writeRaster(r, "o18_prcp_corr")
```












